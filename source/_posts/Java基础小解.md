---
title: Java基础小解
date: 2019-01-23 19:48:52
tags: [Java基础]
categories: [基础学习]
---

## Java基础小解

### 反射

就是在运行状态时，对于任何一个类都可以知道他的方法和属性，对于任何一个对象，都可以调用它的方法和属性；

<!--more-->

这种动态获取类的信息和动态调用对象方法属性的功能称为Java的反射机制。

我们在解剖一个类的时候需要用到类的字节码文件对象，解剖需要利用Class对象中的方法，所以我们就要首先获取Class对象中对应的字节码文件。

Class对象的由来是将字节码文件读入内存然后为之生成一个Class文件。JVM自动创建的，每个类都一定有且只有一个。

![](https://raw.githubusercontent.com/lilihongxian/img/master/20170513133210763.png)

#### 反射获取Class对象的三种方式

1. object.getClass() //通过对象的getClass()方法获取
2. Object.class //通过类的静态属性获取
3. Class.forName(String className) //通过Class类的方法获取

三种方式中最常用的是第三种，第一种都有对象了，还要反射的情况还是比较少的，第二种需要导包，依赖太强了。

常用的Class类的方法有，newInstance(),getDeclar(),getFiled(),getConstructors()等等。

### Exception 异常

![](https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg)

> 红色区域的是表明要抛出或者捕捉的

一张图一看就懂，自定义异常记得继承相应的大类，运行时的继承RuntimeException，非运行时的直接拓展Exception，然后要有四个构造方法

- 一个无参构造函数
- 一个带有String参数的构造函数，并传递给父类的构造函数。
- 一个带有String参数和Throwable参数，并都传递给父类构造函数
- 一个带有Throwable 参数的构造函数，并传递给父类的构造函数。

### IO

![](https://raw.githubusercontent.com/lilihongxian/img/master/1349867949_2253.png)

传统BIO是同步阻塞IO，分类有多种分类：

- 按传输方向分类，分为输入流和输出流
- 按传输数据的数据类型不同可以分为字节流和字符流
- IO流还可以主要分为两大类，节点流和处理流

其中处理流就是对现有的流进行封装和包装并赋予其他的功能进行运用，也有很多分类，比如打印流，缓冲流，转换流，对象流，数据流

现在我们大多使用NIO：

NIO分为三大组件，Channel，Buffer，Selector，NIO可以帮助我们用一个线程处理多个事件

他们之间的联动构成了NIO，相当于非阻塞IO＋IO多路复用，IO多路复用是一种高效的机制，调用select函数时，其内部会维护一张监听的套接字的列表，其会一直阻塞直到其中某一个套接字有数据准备好才返回，并告诉是哪个套接字可读，这时再调用该套接字的read函数效率更高。

联动关系为，首先向Selector中注册Channel事件，通过SelectableChannel.register()方法，然后channel向Buffer中进行输入或者输出

线程模型的分类，Reactor(分为单线程，多线程，多线程主从)，Proactor

其实Reactor就是逐渐拆分单线程的几部分，多线程是拆分出来多个处理线程组，主从是拆分出来多个监听线程池

AIO是异步非阻塞的IO，与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可

BIO是一个连接一个线程。即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

NIO是一个请求一个线程。即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

AIO是一个有效请求一个线程。客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

BIO、NIO、AIO适用场景分析:

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持

#### IO多路复用的机制 select poll epoll

IO多路复用实际上就是维持了一个描述符的集和，一旦某个描述符就绪之后就返回通知程序进行相应的操作，三种函数都可以提供IO多路复用的解决方案，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现

select监控的描述符有三种，writefds、readfds、exceptfds，直到调用到了数据而且有三种动作(即描述符就绪)或者调用超时函数就返回，在此期间调用是阻塞的，返回后通过轮询查找就绪的socket

select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：

1. select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。

　　一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.

2. 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。

　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。

3. 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。

基本原理：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

**它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：**

- 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。
- poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

**基本原理**：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。 

**epoll的优点：**

1. 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。
2. 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。

　　只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。

3. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：

LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。

ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

#### select、poll、epoll区别

##### 支持一个进程所能打开的最大连接数

 ![img](https://raw.githubusercontent.com/lilihongxian/img/master/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A81.png)

##### FD剧增后带来的IO效率问题

 **![img](https://raw.githubusercontent.com/lilihongxian/img/master/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A82.png)**

##### 消息传递方式

 **![img](https://raw.githubusercontent.com/lilihongxian/img/master/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A83.png)**

 

综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：

1. 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2. select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。



