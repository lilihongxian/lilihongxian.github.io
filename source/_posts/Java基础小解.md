## JVM小解

### JVM分区

JVM在管理程序运行的内存时会将他们分为几个不同的运行时数据区域，他们功能各异，有的会随着虚拟机进程的启动而存在，有的则是随着用户线程的创建和结束而建立和销毁。

![1522921173087](https://raw.githubusercontent.com/lilihongxian/img/master/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.jpg)

#### 程序计数器

> 是一块比较小的内存空间，可以看作是当前执行程序的字节码行号指示器，是线程私有的。

我们都知道Java的多线程实际上是通过线程轮流切换实现的，我们为了让切换后的代码执行顺序恢复到原来线程的执行位置，所以我们必须给每个线程都配备一个程序计数器，县城计数器之间各不影响，所以是线程私有的。

在执行Native方法的时候值为空，是唯一一个没有规定任何**OOM**情况的区域。

#### Java虚拟机栈

与程序计数器区是一样的，也是线程私有的，生命周期与Java线程同步，描述的是Java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧用于存储`局部变量表、操作数栈、动态链接、方法出口地址还有一些其他信息`，每一个方法从调用到执行完成都对应着一个方法的入栈和出栈 ，在这一部分规定了两种异常，一个是**OOM**，还有一个就是StackOutFlowError异常，当线程锁申请的栈深度大于虚拟机锁引起的栈的深度就会引起栈溢出异常。

详细的关于局部变量表等结构的描述会在下面讲。

#### 本地方法栈

此区域与虚拟机栈的作用是十分相似的，差别就在于Java虚拟机栈运行的是Java方法，而本地方法栈运行的是Native方法服务。也会抛出上述的两种异常。

#### Java堆

是JVM所管理的内存中最大的一块，被所有线程所共享。此区域存在的唯一目的就是存放对象实例，几乎所有的对象实例都在堆区域。但是现在根据逃逸分析的发展，这句话也不是那么**绝对**了，逃逸分析规定，假如确定一个对象不会逃逸出调用他的方法，那么直接在栈上分配内存不失为一个好主意，逃逸分析在JDK1.6初步实现，还有很大的优化空间。

Java堆还可以从垃圾回收的角度分为年轻代，老年代，其中年轻代还可以分为Eden、From survivor和To survivor，但是无论怎么划分，存储的都是对象实例，划分区域是为了更好的分配内存和回收内存。

Java堆可以处于物理不联系的内存上，只要逻辑上是连续的就可以。堆在实现的时候既可以实现成固定大小的，也可以实现成动态可扩展的，当前主流的都是按照可扩展的来实现的(通过-Xmx和-Xms控制)，如果在堆内存中没有完成实例的内存分配，或者内存已经无法再扩展，就会报出OOM异常。

#### 方法区

> 与Java堆一样是线程共享的内存区域，由于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区有很多人叫他另一个名字**永久代**，两者实际上并不等价，只是HotSpot虚拟机用方法区实现了永久代而已。它的上限是MaxPermSize，默认是64 M。JVM对于方法区的内存管理是十分宽松的，顾名思义永久代中的内存是相对很难回收的，每次垃圾回收在永久代中的表现总是难以让人满意，所以我们在JDK1.8中已经将这部分移除了，用**元空间**作为替代。而在JDK1.7中实际上已经将部分数据移除了，比如字符串常量池，在1.7中已经转移到了堆中。相对容易造成内存泄漏等问题，同样定义了OOM异常。

值得一提的是永久代的垃圾收集是和老年代(old generation)捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。

为什么要移除方法区呢？

1. 字符串存在永久代中，容易出现性能问题和内存溢出。
2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

#### 运行时常量池

> 是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项信息是常量池，用于存放编译期生成的字面量和符号引用，这部分内容将爱类加载后进入方法区的运行时常量池中存放

运行时常量池具有动态性，Java并不要求常量只有编译期才能产生，运行期间也可能将新的常量放入池中。既然运行时常量池是方法区的一部分，那么自然在无法申请到内存时也会抛出OOM异常。

#### 直接内存

> 直接内存并不是JVM运行时数据区域的一部分，也不是JVM所规定的内存区域，但也会被频繁使用

在JDK1.4之后引入了NIO，它可以基于Buffer和Channel直接通过Native方法在堆外分配内存，通过一个叫DirectByteBuffer的对象作为这块内存的引用进行操作。这样做可以在一些场景下显著提高效率。

但是这块区域内存的分配显然是不会受到Java堆内存大小的限制，堆大小在计算的时候是不计入这块内存的，但是直接内存也会受到本机内存大小等因素的限制。

#### 元空间

是一块堆外内存，绝大多数的类元数据的空间都从本地内存中分配。默认情况下，类元数据只受可用的本地内存限制（容量取决于是32/64位操作系统的可用虚拟内存大小）。新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。

元空间的特点：

- 充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。
- 每个加载器有专门的存储空间
- 只进行线性分配
- 不会单独回收某个类
- 省掉了GC扫描及压缩的时间
- 元空间里的对象的位置是固定的
- 如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉

元空间的默认初始大小是21 M，是GC的高水位线，一旦超过就会引来GC，而动态扩展是默认无上限。

值得一提的是元空间的优化，适当的监控和调整元空间，减少元空间的垃圾回收频率是很有必要的，如果发生了频繁的垃圾回收就说明存在了内存泄漏或者是大小设置不合适等问题。

### GC 垃圾回收

为什么和什么是垃圾回收这里就不再提了，现在我们要说的是哪些内存需要回收，什么时候回收以及如何回收？

经过很长时间的演变，我们的自动化垃圾回收机制已经十分完善了，我们主要关注的是动态分配的那一部分内存，我们只有在方法执行期间才能知道哪些对象要创建，对象创建需要多少的内存，而且方法中的每个分支所需要的内存可能也是不一样的。

#### 哪些对象需要回收

现在真正意义上可以作为被回收对象的包括几个：

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象。
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(即一般说的Native方法)引用的对象

这是我们在使用可达性分析法所定义的几种可作为GC Roots的对象，但是实际上还有其他的算法可以作为分析对象是否需要回收。

##### 引用计数法

实际上就是给对象中添加一个引用计数器，有对象引用便加一 ，引用失效就减一，任何时刻假如数值为零就是不可以再被引用的了。在很多时候这不失为一个高效的算法，但是有些场景下这样是解决不了问题的，比如有两个对象他们循环引用 ，这样的话这两个对象就没法再被回收了。

##### 可达性分析算法

基本思想就是通过一系列“GC Roots”的对象作为起始点，开始向下搜索，他们所走过的路成为引用链，当一个对象没有经过任何引用链的时候，他就是可以被回收的对象，是不可用的。

##### 再谈引用

其实就是四种引用，强引用、软引用、弱引用和虚引用