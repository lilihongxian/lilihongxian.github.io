<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础小解</title>
      <link href="/2019/01/24/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%A7%A3/"/>
      <url>/2019/01/24/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 23:57:48 GMT+0800 (GMT+08:00) --><h2 id="Java基础小解"><a href="#Java基础小解" class="headerlink" title="Java基础小解"></a>Java基础小解</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>就是在运行状态时，对于任何一个类都可以知道他的方法和属性，对于任何一个对象，都可以调用它的方法和属性；</p><a id="more"></a><p>这种动态获取类的信息和动态调用对象方法属性的功能称为Java的反射机制。</p><p>我们在解剖一个类的时候需要用到类的字节码文件对象，解剖需要利用Class对象中的方法，所以我们就要首先获取Class对象中对应的字节码文件。</p><p>Class对象的由来是将字节码文件读入内存然后为之生成一个Class文件。JVM自动创建的，每个类都一定有且只有一个。</p><p><img src="https://raw.githubusercontent.com/lilihongxian/img/master/20170513133210763.png" alt=""></p><h4 id="反射获取Class对象的三种方式"><a href="#反射获取Class对象的三种方式" class="headerlink" title="反射获取Class对象的三种方式"></a>反射获取Class对象的三种方式</h4><ol><li>object.getClass() //通过对象的getClass()方法获取</li><li>Object.class //通过类的静态属性获取</li><li>Class.forName(String className) //通过Class类的方法获取</li></ol><p>三种方式中最常用的是第三种，第一种都有对象了，还要反射的情况还是比较少的，第二种需要导包，依赖太强了。</p><p>常用的Class类的方法有，newInstance(),getDeclar(),getFiled(),getConstructors()等等。</p><h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception 异常"></a>Exception 异常</h3><p><img src="https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg" alt=""></p><blockquote><p>红色区域的是表明要抛出或者捕捉的</p></blockquote><p>一张图一看就懂，自定义异常记得继承相应的大类，运行时的继承RuntimeException，非运行时的直接拓展Exception，然后要有四个构造方法</p><ul><li>一个无参构造函数</li><li>一个带有String参数的构造函数，并传递给父类的构造函数。</li><li>一个带有String参数和Throwable参数，并都传递给父类构造函数</li><li>一个带有Throwable 参数的构造函数，并传递给父类的构造函数。</li></ul><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p><img src="https://raw.githubusercontent.com/lilihongxian/img/master/1349867949_2253.png" alt=""></p><p>传统BIO是同步阻塞IO，分类有多种分类：</p><ul><li>按传输方向分类，分为输入流和输出流</li><li>按传输数据的数据类型不同可以分为字节流和字符流</li><li>IO流还可以主要分为两大类，节点流和处理流</li></ul><p>其中处理流就是对现有的流进行封装和包装并赋予其他的功能进行运用，也有很多分类，比如打印流，缓冲流，转换流，对象流，数据流</p><p>现在我们大多使用NIO：</p><p>NIO分为三大组件，Channel，Buffer，Selector，NIO可以帮助我们用一个线程处理多个事件</p><p>他们之间的联动构成了NIO，相当于非阻塞IO＋IO多路复用，IO多路复用是一种高效的机制，调用select函数时，其内部会维护一张监听的套接字的列表，其会一直阻塞直到其中某一个套接字有数据准备好才返回，并告诉是哪个套接字可读，这时再调用该套接字的read函数效率更高。</p><p>联动关系为，首先向Selector中注册Channel事件，通过SelectableChannel.register()方法，然后channel向Buffer中进行输入或者输出</p><p>线程模型的分类，Reactor(分为单线程，多线程，多线程主从)，Proactor</p><p>其实Reactor就是逐渐拆分单线程的几部分，多线程是拆分出来多个处理线程组，主从是拆分出来多个监听线程池</p><p>AIO是异步非阻塞的IO，与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可</p><p>BIO是一个连接一个线程。即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>NIO是一个请求一个线程。即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>AIO是一个有效请求一个线程。客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p>BIO、NIO、AIO适用场景分析:</p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持</p><h4 id="IO多路复用的机制-select-poll-epoll"><a href="#IO多路复用的机制-select-poll-epoll" class="headerlink" title="IO多路复用的机制 select poll epoll"></a>IO多路复用的机制 select poll epoll</h4><p>IO多路复用实际上就是维持了一个描述符的集和，一旦某个描述符就绪之后就返回通知程序进行相应的操作，三种函数都可以提供IO多路复用的解决方案，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p>select监控的描述符有三种，writefds、readfds、exceptfds，直到调用到了数据而且有三种动作(即描述符就绪)或者调用超时函数就返回，在此期间调用是阻塞的，返回后通过轮询查找就绪的socket</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><ol><li>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</li></ol><p>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><ol><li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</li></ol><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><ol><li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ol><p>基本原理：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</strong></p><ul><li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li><li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li></ul><p>注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><p><strong>基本原理</strong>：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>epoll的优点：</strong></p><ol><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。</li></ol><p>只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><ol><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li></ol><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h4 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h4><h5 id="支持一个进程所能打开的最大连接数"><a href="#支持一个进程所能打开的最大连接数" class="headerlink" title="支持一个进程所能打开的最大连接数"></a>支持一个进程所能打开的最大连接数</h5><p><img src="https://raw.githubusercontent.com/lilihongxian/img/master/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A81.png" alt="img"></p><h5 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h5><p><strong><img src="https://raw.githubusercontent.com/lilihongxian/img/master/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A82.png" alt="img"></strong></p><h5 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h5><p><strong><img src="https://raw.githubusercontent.com/lilihongxian/img/master/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A83.png" alt="img"></strong></p><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p><ol><li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li><li>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列的学习(二)</title>
      <link href="/2019/01/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>/2019/01/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 23:36:35 GMT+0800 (GMT+08:00) --><p>我们上节讲述了关于消息队列的概述，以及他的通讯模式分类，其实都是很抽象化的一些东西，学起来相对来说会无趣一些，这一节我们来讲述关于消息队列的优劣和应用场景。通过这些比较切合实际的东西来加强对它的理解。</p><a id="more"></a><h2 id="消息队列的优劣比较"><a href="#消息队列的优劣比较" class="headerlink" title="消息队列的优劣比较"></a>消息队列的优劣比较</h2><h3 id="消息队列的优势"><a href="#消息队列的优势" class="headerlink" title="消息队列的优势"></a>消息队列的优势</h3><ol><li>解耦合</li><li>削峰控流</li><li>异步</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> MessageQueue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> 技术学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列的学习(一)</title>
      <link href="/2019/01/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>/2019/01/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 23:36:35 GMT+0800 (GMT+08:00) --><h3 id="图片大纲"><a href="#图片大纲" class="headerlink" title="图片大纲"></a>图片大纲</h3><p><img src="https://raw.githubusercontent.com/lilihongxian/img/master/MessageQueue.png" alt="MessageQueue"></p><a id="more"></a><blockquote><p>想要系统的学习消息队列，我们首先需要对它有一个系统的认识 ，什么是消息队列？</p></blockquote><h3 id="消息队列的概述"><a href="#消息队列的概述" class="headerlink" title="消息队列的概述"></a>消息队列的概述</h3><p>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。</p><p>在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。</p><p>消息队列为构造以同步或异步方式实现的分布式应用提供了松耦合方法。消息队列的API调用被嵌入到新的或现存的应用中，通过消息发送到内存或基于磁盘的队列或从它读出而提供信息交换。消息队列可用在应用中以执行多种功能，比如要求服务、交换信息或异步处理等。</p><p>中间件是一种独立的系统软件或服务程序，分布式应用系统借助这种软件在不同的技术之间共享资源，管理计算资源和网络通讯。它在计算机系统中是一个关键软件，它能实现应用的互连和互操作性，能保证系统的安全、可靠、高效的运行。中间件位于用户应用和操作系统及网络软件之间，它为应用提供了公用的通信手段，并且独立于网络和操作系统。中间件为开发者提供了公用于所有环境的应用程序接口，当应用程序中嵌入其函数调用，它便可利用其运行的特定操作系统和网络环境的功能，为应用执行通信功能。</p><p>如果没有消息中间件完成信息交换，应用开发者为了传输数据，必须要学会如何用网络和操作系统软件的功能，编写相应的应用程序来发送和接收信息，且交换信息没有标准方法，每个应用必须进行特定的编程从而和多平台、不同环境下的一个或多个应用通信。例如，为了实现网络上不同主机系统间的通信，将要求具备在网络上如何交换信息的知识（比如用TCP/IP的socket程序设计）；为了实现同一主机内不同进程之间的通讯，将要求具备操作系统的消息队列或命名管道(Pipes)等知识。</p><p>上面的叙述也是直接说明了消息队列的一个优势，即解耦。他的平台无关性或者说消除不同系统之间的差异性很多时候省去了我们一些学习成本，使得我们再开发应用的时候传递消息不用再考虑特定的系统用相应的传输方式传输；其他优点类似削峰控流，异步等会再下一部分进行比较详细的叙述。</p><blockquote><p>现在我们再来介绍一下他的通讯模式分类</p></blockquote><h3 id="通讯模式分类"><a href="#通讯模式分类" class="headerlink" title="通讯模式分类"></a>通讯模式分类</h3><p>首先先来解释一下为什么要将通讯模式分类，我们知道现实世界的应用场景的非常复杂的，所以在应用消息队列的时候我们不可能说一种模式就可以应对所有的应用场景，那么我们在消息队列中就分出几种通讯模式来应对不同的场景，根据实际情况选择合适的模式，这样有利于我们减少资源的消耗，而且可以更好地满足需求。</p><ol><li>点对点通讯：点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</li><li>多点广播：MQ适用于不同类型的应用。其中重要的，也是正在发展中的是”多点广播”应用，即能够将消息发送到多个目标站点(Destination List)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</li><li>发布/订阅(Publish/Subscribe)模式：发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。在MQ家族产品中，MQ Event Broker是专门用于使用发布/订阅技术进行数据通讯的产品，它支持基于队列和直接基于TCP/IP两种方式的发布和订阅。</li><li>群集(Cluster)：为了简化点对点通讯模式中的系统配置，MQ提供Cluster(群集)的解决方案。群集类似于一个域(Domain)，群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集(Cluster)通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</li></ol><blockquote><p>现在我拿点对点模式和发布/订阅模式做一个解释和对比：</p></blockquote><h4 id="点对点模式-不可重复消费"><a href="#点对点模式-不可重复消费" class="headerlink" title="点对点模式 (不可重复消费)"></a>点对点模式 (不可重复消费)</h4><p>点对点模式下包括三个角色：</p><ul><li>消息队列</li><li>发送者 (生产者)</li><li>接收者（消费者）</li></ul><p><img src="https://blog-10039692.file.myqcloud.com/1506330130593_2564_1506330132919.png" alt="p2p"></p><p>消息发送者生产消息发送到queue中，然后消息接收者从queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息接收者不可能消费到已经被消费的消息。<strong>queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</strong></p><p>点对点模式特点：</p><ul><li>每个消息只有一个接收者（Consumer）(即一旦被消费，消息就不再在消息队列中)；</li><li>发送者和接收者间没有依赖性，发送者发送消息之后，不管有没有接收者在运行，都不会影响到发送者下次发送消息；</li><li>接收者在成功接收消息之后需向队列应答成功，以便消息队列删除当前接收的消息；</li></ul><h4 id="发布-订阅模式-可以重复消费"><a href="#发布-订阅模式-可以重复消费" class="headerlink" title="发布/订阅模式 (可以重复消费)"></a>发布/订阅模式 (可以重复消费)</h4><p>发布/订阅模式下包括三个角色：</p><ul><li>角色主题（Topic）</li><li>发布者(Publisher)</li><li>订阅者(Subscriber)</li></ul><p><img src="https://blog-10039692.file.myqcloud.com/1506330158945_9538_1506330161280.png" alt=""></p><p>发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。同时有多个消息消费者（订阅）消费该消息。<strong>和点对点方式不同，发布到topic的消息会被所有订阅者消费。</strong></p><p>发布/订阅模式特点：</p><ul><li>每个消息可以有多个订阅者；</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行；</li></ul><p>支持订阅组的发布订阅模式：<br>发布订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。实际上现实场景中是多个订阅者节点组成一个订阅组负载均衡消费topic消息即分组订阅，这样订阅者很容易实现消费能力线性扩展。<strong>可以看成是一个topic下有多个Queue，每个Queue是点对点的方式，Queue之间是发布订阅方式。</strong></p><p><img src="https://raw.githubusercontent.com/lilihongxian/img/master/20151201162825775.jpg" alt="发布/订阅"></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h5><p>生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，所以Queue实现了一个可靠的负载均衡。</p><h5 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h5><p>发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到这个消息的拷贝。</p><p>这一部分主要是讲述了消息队列的概念和其通讯模式的分类，在下一部分会讲述其作用和应用场景，用兴趣的同学可以关注一下！</p><font face="微软雅黑" size="3" color="#FF0000">本文主要用于个人学习和总结，侵权请联系删除</font><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> MessageQueue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> 技术学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
